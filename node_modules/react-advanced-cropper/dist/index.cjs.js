'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var advancedCropper = require('advanced-cropper');
var service = require('advanced-cropper/service');
var state = require('advanced-cropper/state');
var cn = require('classnames');
var stencilSize = require('advanced-cropper/extensions/stencil-size');
var defaults = require('advanced-cropper/defaults');
var algorithms = require('advanced-cropper/algorithms');
var image = require('advanced-cropper/image');
var canvas = require('advanced-cropper/canvas');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var cn__default = /*#__PURE__*/_interopDefaultLegacy(cn);

function hybridStencilAutoZoomAlgorithm(state$1, settings) {
    if (service.isInitializedState(state$1)) {
        var result = state.copyState(state$1);
        // Checks that coordinates has the same ratio that coordinates:
        var stencil = {
            width: 0,
            height: 0,
        };
        if (service.ratio(result.boundary) > service.ratio(result.coordinates)) {
            stencil.height = result.boundary.height * 0.8;
            stencil.width = stencil.height * service.ratio(result.coordinates);
        }
        else {
            stencil.width = result.boundary.width * 0.8;
            stencil.height = stencil.width * service.ratio(result.coordinates);
        }
        // First of all try to resize visible area as much as possible:
        result.visibleArea = service.applyScale(result.visibleArea, (result.coordinates.width * result.boundary.width) / (result.visibleArea.width * stencil.width));
        // Check that visible area doesn't break the area restrictions:
        var scale = service.fitToSizeRestrictions(result.visibleArea, service.getAreaSizeRestrictions(result, settings));
        result.visibleArea = service.applyScale(result.visibleArea, scale);
        if (scale !== 1) {
            stencil.height /= scale;
            stencil.width /= scale;
        }
        result.visibleArea = service.applyMove(result.visibleArea, service.diff(service.getCenter(result.coordinates), service.getCenter(result.visibleArea)));
        // Center stencil in visible area:
        result.visibleArea = service.moveToPositionRestrictions(result.visibleArea, service.getAreaPositionRestrictions(result, settings));
        result.coordinates = service.moveToPositionRestrictions(result.coordinates, service.mergePositionRestrictions(service.coordinatesToPositionRestrictions(result.visibleArea), service.getPositionRestrictions(result, settings)));
        return result;
    }
    return state$1;
}
function hybridStencilAutoZoom(state, settings, action) {
    if (action.immediately) {
        return hybridStencilAutoZoomAlgorithm(state, settings);
    }
    return state;
}

function deprecationWarning(text) {
    if (process.env.NODE_ENV === 'development') {
        console.warn("Deprecation warning: ".concat(text));
    }
}

function useDeprecationWarning() {
    var fired = React.useRef([]);
    return function (message) {
        if (fired.current.indexOf(message) === -1) {
            deprecationWarning(message);
            fired.current.push(message);
        }
    };
}

function createCropper(render) {
    return React.forwardRef(render);
}

function useFirstMountState() {
    var isFirst = React.useRef(true);
    if (isFirst.current) {
        isFirst.current = false;
        return true;
    }
    return isFirst.current;
}

var useUpdateEffect = function (effect, deps) {
    var isFirstMount = useFirstMountState();
    React.useEffect(function () {
        if (!isFirstMount) {
            return effect();
        }
    }, deps);
};

function useStateWithCallback(initialState) {
    var _a = tslib.__read(React.useState(initialState), 2), state = _a[0], setState = _a[1];
    var _b = tslib.__read(React.useState(null), 2), callback = _b[0], setCallback = _b[1];
    var previousState = React.useRef(initialState);
    useUpdateEffect(function () {
        if (callback) {
            callback(state, previousState.current);
        }
    }, [callback]);
    return [
        state,
        function (value, callback) {
            previousState.current = state;
            setState(value);
            setCallback(function () { return callback; });
        }
    ];
}

var CropperInstance = /** @class */ (function (_super) {
    tslib.__extends(CropperInstance, _super);
    function CropperInstance(props, onChange) {
        var _this = _super.call(this) || this;
        _this.props = props;
        _this.notify = onChange;
        _this.data = {
            state: null,
            transitions: false,
            interactions: advancedCropper.getEmptyInteractions(),
        };
        return _this;
    }
    CropperInstance.prototype.getProps = function () {
        return this.props();
    };
    CropperInstance.prototype.setData = function (data) {
        this.data = data;
        this.notify();
    };
    CropperInstance.prototype.getData = function () {
        return this.data;
    };
    return CropperInstance;
}(advancedCropper.AbstractCropperInstance));

function useForceRerender() {
    var _a = tslib.__read(React.useState({}), 2); _a[0]; var setTick = _a[1];
    return function () {
        setTick({});
    };
}

function usePersistentFunction(props) {
    var propsRef = React.useRef(props);
    propsRef.current = props;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return propsRef.current.apply(propsRef, tslib.__spreadArray([], tslib.__read(args), false));
    };
}

function useCropperInstance(props) {
    var rerender = useForceRerender();
    var getProps = usePersistentFunction(function () {
        var _a = props(), settings = _a.settings, parameters = tslib.__rest(_a, ["settings"]);
        var extendedSettings = tslib.__assign({ imageRestriction: advancedCropper.ImageRestriction.fitArea, transformImage: {
                adjustStencil: true,
            } }, settings);
        var extendedParameters = tslib.__assign({ transitions: true }, parameters);
        return tslib.__assign({ settings: tslib.__assign(tslib.__assign({}, extendedSettings), advancedCropper.createDefaultSettings(extendedSettings)) }, extendedParameters);
    });
    var cropper = React.useRef(new CropperInstance(getProps, rerender));
    return cropper.current;
}

function useCropperImage(options) {
    var src = options.src, onLoadingStart = options.onLoadingStart, onLoadingEnd = options.onLoadingEnd, onError = options.onError, onLoad = options.onLoad, crossOrigin = options.crossOrigin, checkOrientation = options.checkOrientation, canvas = options.canvas, unloadTime = options.unloadTime;
    var _a = tslib.__read(React.useState(false), 2), loading = _a[0], setLoading = _a[1];
    var _b = tslib.__read(React.useState(false), 2), loaded = _b[0], setLoaded = _b[1];
    var _c = tslib.__read(React.useState(null), 2), image = _c[0], setImage = _c[1];
    var currentSrc = React.useRef(null);
    React.useEffect(function () {
        if (currentSrc.current !== src) {
            currentSrc.current = src || null;
            setLoaded(false);
            if (src) {
                setLoading(true);
                onLoadingStart === null || onLoadingStart === void 0 ? void 0 : onLoadingStart();
                var promises = [
                    advancedCropper.loadImage(src, {
                        crossOrigin: advancedCropper.isUndefined(crossOrigin) ? canvas : crossOrigin,
                        checkOrientation: checkOrientation,
                    }),
                ];
                if (loaded && unloadTime) {
                    promises.push(advancedCropper.promiseTimeout(unloadTime));
                }
                Promise.all(promises)
                    .then(function (responses) {
                    var _a = tslib.__read(responses, 1), image = _a[0];
                    if (currentSrc.current === src) {
                        setImage(image);
                        onLoad === null || onLoad === void 0 ? void 0 : onLoad(image);
                    }
                })
                    .catch(function () {
                    if (currentSrc.current === src) {
                        onError === null || onError === void 0 ? void 0 : onError();
                    }
                })
                    .finally(function () {
                    if (currentSrc.current === src) {
                        onLoadingEnd === null || onLoadingEnd === void 0 ? void 0 : onLoadingEnd();
                        setLoading(false);
                    }
                });
            }
            else {
                if (unloadTime) {
                    advancedCropper.promiseTimeout(unloadTime).then(function () {
                        setImage(null);
                    });
                }
                else {
                    setImage(null);
                }
            }
        }
    }, [src]);
    React.useEffect(function () {
        if (image) {
            setLoaded(true);
        }
    }, [image]);
    return {
        isLoading: function () {
            return loading;
        },
        isLoaded: function () {
            return loaded;
        },
        getImage: function () {
            return image;
        },
        setImage: setImage,
    };
}

var useWindowResize = function (callback) {
    var callbackRef = React.useRef(callback);
    var internalCallback = function () {
        if (callbackRef.current) {
            callbackRef.current();
        }
    };
    React.useEffect(function () {
        callbackRef.current = callback;
    }, [callback]);
    React.useEffect(function () {
        window.addEventListener('resize', internalCallback);
        window.addEventListener('orientationchange', internalCallback);
        return function () {
            window.removeEventListener('resize', internalCallback);
            window.removeEventListener('orientationchange', internalCallback);
        };
    }, []);
};

function useCropperAutoReconcile(cropper, enabled) {
    if (enabled === void 0) { enabled = true; }
    var _a = tslib.__read(React.useState(enabled), 2), active = _a[0], setActive = _a[1];
    React.useLayoutEffect(function () {
        if (active && !cropper.hasInteractions()) {
            cropper.reconcileState();
        }
    });
    return {
        pause: function () {
            setActive(false);
        },
        resume: function () {
            setActive(true);
        },
    };
}

function useAbstractCropper(props) {
    var _this = this;
    var _a = props(), src = _a.src, onReady = _a.onReady, onError = _a.onError, onUpdate = _a.onUpdate, _b = _a.canvas, canvas = _b === void 0 ? true : _b, _c = _a.unloadTime, unloadTime = _c === void 0 ? 500 : _c, _d = _a.crossOrigin, crossOrigin = _d === void 0 ? true : _d, _e = _a.checkOrientation, checkOrientation = _e === void 0 ? true : _e, _f = _a.autoReconcileState, autoReconcileState = _f === void 0 ? true : _f;
    var imageRef = React.useRef(null);
    var boundaryRef = React.useRef(null);
    var canvasRef = React.useRef(null);
    var cropperRef = React.useRef(null);
    var _g = tslib.__read(useStateWithCallback(null), 2), currentImage = _g[0], setCurrentImage = _g[1];
    var cropper = useCropperInstance(function () { return (tslib.__assign(tslib.__assign({}, props()), { getInstance: function () {
            return cropperRef.current;
        } })); });
    var cropperImage = useCropperImage({
        src: src,
        crossOrigin: crossOrigin,
        checkOrientation: checkOrientation,
        unloadTime: unloadTime,
        canvas: canvas,
        onLoad: function () {
            if (cropperRef.current) {
                onReady === null || onReady === void 0 ? void 0 : onReady(cropperRef.current);
            }
        },
        onError: function () {
            if (cropperRef.current) {
                onError === null || onError === void 0 ? void 0 : onError(cropperRef.current);
            }
        },
    });
    var autoReconcile = useCropperAutoReconcile(cropper, autoReconcileState);
    var resetCropper = function () { return tslib.__awaiter(_this, void 0, void 0, function () {
        var image_1, boundary_1;
        var _a;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!boundaryRef.current) return [3 /*break*/, 2];
                    autoReconcile.pause();
                    image_1 = cropperImage.getImage();
                    return [4 /*yield*/, ((_a = boundaryRef.current) === null || _a === void 0 ? void 0 : _a.stretchTo(image_1))];
                case 1:
                    boundary_1 = _b.sent();
                    setCurrentImage(image_1, function () {
                        if (boundary_1 && image_1) {
                            cropper.reset(boundary_1, image_1);
                        }
                        else {
                            cropper.clear();
                        }
                    });
                    autoReconcile.resume();
                    _b.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    }); };
    var refreshCropper = function () { return tslib.__awaiter(_this, void 0, void 0, function () {
        var image, boundary, state;
        var _a;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!boundaryRef.current) return [3 /*break*/, 2];
                    autoReconcile.pause();
                    image = cropperImage.getImage();
                    return [4 /*yield*/, ((_a = boundaryRef.current) === null || _a === void 0 ? void 0 : _a.stretchTo(image))];
                case 1:
                    boundary = _b.sent();
                    if (boundary && image) {
                        state = cropper.getState();
                        if (state) {
                            if (boundary.width !== state.boundary.width || boundary.height !== state.boundary.height) {
                                cropper.setBoundary(boundary);
                                // It's important because, probably, after the boundary reset
                                // the cropper can meet some restrictions that were broken before
                                cropper.reconcileState();
                            }
                        }
                        else {
                            cropper.reset(boundary, image);
                        }
                    }
                    else {
                        cropper.clear();
                    }
                    autoReconcile.resume();
                    _b.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    }); };
    var cropperInterface = {
        reset: function () { return resetCropper(); },
        refresh: function () { return refreshCropper(); },
        setImage: function (image) { return setCurrentImage(image); },
        reconcileState: cropper.reconcileState,
        moveCoordinates: cropper.moveCoordinates,
        moveCoordinatesEnd: cropper.moveCoordinatesEnd,
        resizeCoordinates: cropper.resizeCoordinates,
        clear: cropper.clear,
        resizeCoordinatesEnd: cropper.resizeCoordinatesEnd,
        moveImage: cropper.moveImage,
        flipImage: cropper.flipImage,
        zoomImage: cropper.zoomImage,
        rotateImage: cropper.rotateImage,
        transformImage: cropper.transformImage,
        transformImageEnd: cropper.transformImageEnd,
        setCoordinates: cropper.setCoordinates,
        setVisibleArea: cropper.setVisibleArea,
        startTransitions: cropper.startTransitions,
        setState: cropper.setState,
        hasInteractions: cropper.hasInteractions,
        getStencilCoordinates: cropper.getStencilCoordinates,
        getCoordinates: cropper.getCoordinates,
        getVisibleArea: cropper.getVisibleArea,
        getTransforms: cropper.getTransforms,
        getTransitions: cropper.getTransitions,
        getInteractions: cropper.getInteractions,
        getSettings: cropper.getSettings,
        getState: cropper.getState,
        getDefaultState: function () {
            var state = cropper.getState();
            var image = cropperImage.getImage();
            if (state && image) {
                return cropper.createDefaultState(state.boundary, image);
            }
            else {
                return null;
            }
        },
        getCanvas: function (options) {
            var state = cropper.getState();
            if (imageRef.current && canvasRef.current && state) {
                return canvasRef.current.draw(state, imageRef.current, options);
            }
            else {
                return null;
            }
        },
        getImage: function () {
            return currentImage ? tslib.__assign({}, currentImage) : null;
        },
        isLoading: cropperImage.isLoading,
        isLoaded: cropperImage.isLoaded,
    };
    useWindowResize(function () {
        refreshCropper();
    });
    useUpdateEffect(function () {
        resetCropper();
    }, [cropperImage.getImage()]);
    useUpdateEffect(function () {
        if (cropperRef.current) {
            onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(cropperRef.current);
        }
    }, [cropperImage.isLoaded(), cropperImage.isLoading()]);
    React.useImperativeHandle(cropperRef, function () { return cropperInterface; });
    return {
        cropper: cropperInterface,
        refs: {
            image: imageRef,
            boundary: boundaryRef,
            canvas: canvasRef,
        },
        image: currentImage,
    };
}

var StretchableBoundary = React.forwardRef(function (_a, ref) {
    var className = _a.className, style = _a.style, stretcherClassName = _a.stretcherClassName, contentClassName = _a.contentClassName, _b = _a.stretchAlgorithm, stretchAlgorithm = _b === void 0 ? advancedCropper.stretchCropperBoundary : _b, _c = _a.sizeAlgorithm, sizeAlgorithm = _c === void 0 ? advancedCropper.fillBoundary : _c, children = _a.children;
    var stretcherRef = React.useRef(null);
    var boundaryRef = React.useRef(null);
    React.useImperativeHandle(ref, function () { return ({
        reset: function () {
            var stretcher = stretcherRef.current;
            if (stretcher) {
                stretcher.style.height = '';
                stretcher.style.width = '';
            }
        },
        stretchTo: function (size) {
            var stretcher = stretcherRef.current;
            var boundary = boundaryRef.current;
            if ((size === null || size === void 0 ? void 0 : size.width) && (size === null || size === void 0 ? void 0 : size.height) && stretcher && boundary) {
                stretchAlgorithm(boundary, stretcher, size);
                var result = sizeAlgorithm(boundary, size);
                return Promise.resolve(result.width && result.height ? result : null);
            }
            else {
                if (stretcher) {
                    stretcher.style.height = '';
                    stretcher.style.width = '';
                }
                return Promise.resolve(null);
            }
        },
    }); });
    return (React__default["default"].createElement("div", { ref: boundaryRef, style: style, className: cn__default["default"]('advanced-cropper-boundary', className) },
        React__default["default"].createElement("div", { ref: stretcherRef, className: cn__default["default"](['advanced-cropper-boundary__stretcher', stretcherClassName]) }),
        React__default["default"].createElement("div", { className: cn__default["default"](['advanced-cropper-boundary__content', contentClassName]) }, children)));
});
StretchableBoundary.displayName = 'StretchableBoundary';

var CropperFade = function (_a) {
    var visible = _a.visible, className = _a.className, style = _a.style, children = _a.children;
    return (React__default["default"].createElement("div", { style: style, className: cn__default["default"](className, 'advanced-cropper-fade', Boolean(visible) && 'advanced-cropper-fade--visible') }, children));
};

var CropperWrapper = function (_a) {
    var cropper = _a.cropper, children = _a.children, className = _a.className, style = _a.style;
    var state = cropper ? cropper.getState() : null;
    var loaded = cropper ? cropper.isLoaded() : false;
    return (React__default["default"].createElement("div", { className: cn__default["default"](className, 'advanced-cropper-wrapper'), style: style },
        React__default["default"].createElement(CropperFade, { visible: state && loaded, className: 'advanced-cropper-wrapper__fade' }, children)));
};

function preventDefault(e) {
    e.preventDefault();
}

var CropperBackgroundImage = React.forwardRef(function (_a, ref) {
    var className = _a.className, style = _a.style, cropper = _a.cropper, _b = _a.crossOrigin, crossOrigin = _b === void 0 ? true : _b;
    var state = cropper.getState();
    var transitions = cropper.getTransitions();
    var image = cropper.getImage();
    var transformStyles = image && state ? advancedCropper.getBackgroundStyle(image, state, transitions) : {};
    var src = image ? image.src : undefined;
    return src ? (React__default["default"].createElement("img", { key: src, ref: ref, className: cn__default["default"]('advanced-cropper-background-image', className), src: src, crossOrigin: crossOrigin === true ? 'anonymous' : crossOrigin || undefined, style: tslib.__assign(tslib.__assign({}, transformStyles), style), onMouseDown: preventDefault })) : null;
});
CropperBackgroundImage.displayName = 'CropperBackgroundImage';

var CropperCanvas = React.forwardRef(function (_, ref) {
    var canvasRef = React.useRef(null);
    var spareCanvasRef = React.useRef(null);
    React.useImperativeHandle(ref, function () { return ({
        draw: function (state, image, options) {
            if (options === void 0) { options = {}; }
            if (image && canvasRef.current && spareCanvasRef.current) {
                return advancedCropper.drawCroppedArea(state, image, canvasRef.current, spareCanvasRef.current, options);
            }
            else {
                return null;
            }
        },
    }); });
    return (React__default["default"].createElement(React__default["default"].Fragment, null,
        React__default["default"].createElement("canvas", { className: "advanced-cropper-canvas", ref: canvasRef }),
        React__default["default"].createElement("canvas", { className: "advanced-cropper-canvas", ref: spareCanvasRef })));
});
CropperCanvas.displayName = 'CropperCanvas';

var DraggableElement = /** @class */ (function (_super) {
    tslib.__extends(DraggableElement, _super);
    function DraggableElement(props) {
        var _this = _super.call(this, props) || this;
        _this.processMove = function (e, newTouches) {
            var _a;
            var container = _this.container.current;
            if (container && _this.touches.length) {
                var _b = container.getBoundingClientRect(), left = _b.left, top_1 = _b.top;
                if (_this.touches.length === 1 && newTouches.length === 1) {
                    if (_this.props.onMove) {
                        var movingToAnchor = {
                            left: Math.abs(newTouches[0].clientX - _this.anchor.left - left) <
                                Math.abs(_this.touches[0].clientX - _this.anchor.left - left),
                            top: Math.abs(newTouches[0].clientY - _this.anchor.top - top_1) <
                                Math.abs(_this.touches[0].clientY - _this.anchor.top - top_1),
                        };
                        var direction = {
                            left: 0,
                            top: 0,
                        };
                        if (!_this.props.useAnchor || !movingToAnchor.left) {
                            direction.left = newTouches[0].clientX - _this.touches[0].clientX;
                        }
                        if (!_this.props.useAnchor || !movingToAnchor.top) {
                            direction.top = newTouches[0].clientY - _this.touches[0].clientY;
                        }
                        (_a = _this.props) === null || _a === void 0 ? void 0 : _a.onMove(direction, e);
                        _this.touches = tslib.__spreadArray([], tslib.__read(newTouches), false);
                    }
                }
            }
        };
        _this.processEnd = function () {
            var _a = _this.props, onMoveEnd = _a.onMoveEnd, onLeave = _a.onLeave;
            if (!_this.props.disabled && _this.touches.length) {
                onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd();
            }
            if (_this.hovered) {
                onLeave === null || onLeave === void 0 ? void 0 : onLeave();
                _this.hovered = false;
            }
            _this.touches = [];
        };
        _this.initAnchor = function (touch) {
            var container = _this.container.current;
            if (container) {
                var _a = container.getBoundingClientRect(), left = _a.left, top_2 = _a.top;
                _this.anchor = {
                    left: touch.clientX - left,
                    top: touch.clientY - top_2,
                };
            }
        };
        _this.onMouseOver = function () {
            var _a = _this.props, onEnter = _a.onEnter, disabled = _a.disabled;
            if (!_this.hovered && !disabled) {
                _this.hovered = true;
                onEnter === null || onEnter === void 0 ? void 0 : onEnter();
            }
        };
        _this.onMouseLeave = function () {
            var onLeave = _this.props.onLeave;
            if (_this.hovered && !_this.touches.length) {
                _this.hovered = false;
                onLeave === null || onLeave === void 0 ? void 0 : onLeave();
            }
        };
        _this.onTouchStart = function (e) {
            var _a = _this.props, onEnter = _a.onEnter, onMoveStart = _a.onMoveStart, disabled = _a.disabled;
            if (e.cancelable) {
                _this.touches = Array.from(e.touches);
                var shouldStartMove = !disabled && e.touches.length === 1;
                if (shouldStartMove) {
                    _this.touches = Array.from(e.touches);
                    onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart();
                }
                if (!_this.hovered && !disabled) {
                    _this.hovered = true;
                    onEnter === null || onEnter === void 0 ? void 0 : onEnter();
                }
                if (_this.started || shouldStartMove) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }
        };
        _this.onTouchEnd = function () {
            _this.started = false;
            _this.processEnd();
        };
        _this.onTouchMove = function (e) {
            if (_this.touches.length >= 1) {
                if (_this.started) {
                    _this.processMove(e, Array.from(e.touches));
                    e.preventDefault();
                    e.stopPropagation();
                }
                else if (advancedCropper.distance({ left: _this.touches[0].clientX, top: _this.touches[0].clientY }, { left: e.touches[0].clientX, top: e.touches[0].clientY }) > (_this.props.activationDistance || 0)) {
                    _this.initAnchor({
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY,
                    });
                    _this.started = true;
                }
            }
        };
        _this.onMouseDown = function (e) {
            var _a = _this.props, onMoveStart = _a.onMoveStart, disabled = _a.disabled;
            if (!disabled && e.button === 0) {
                var touch = {
                    clientX: e.clientX,
                    clientY: e.clientY,
                };
                _this.touches = [touch];
                _this.initAnchor(touch);
                e.stopPropagation();
                onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart();
            }
        };
        _this.onMouseMove = function (e) {
            if (!_this.props.disabled && _this.touches.length) {
                _this.processMove(e, [
                    {
                        clientX: e.clientX,
                        clientY: e.clientY,
                    },
                ]);
                if (e.preventDefault && e.cancelable) {
                    e.preventDefault();
                }
                e.stopPropagation();
            }
        };
        _this.onMouseUp = function () {
            _this.processEnd();
        };
        _this.touches = [];
        _this.hovered = false;
        _this.started = false;
        _this.anchor = {
            left: 0,
            top: 0,
        };
        _this.container = React.createRef();
        return _this;
    }
    DraggableElement.prototype.componentWillUnmount = function () {
        window.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('touchmove', this.onTouchMove);
        window.removeEventListener('touchend', this.onTouchEnd);
        var container = this.container.current;
        if (container) {
            container.removeEventListener('touchstart', this.onTouchStart);
            container.removeEventListener('mousedown', this.onMouseDown);
        }
    };
    DraggableElement.prototype.componentDidMount = function () {
        window.addEventListener('mouseup', this.onMouseUp, { passive: false });
        window.addEventListener('mousemove', this.onMouseMove, { passive: false });
        window.addEventListener('touchmove', this.onTouchMove, { passive: false });
        window.addEventListener('touchend', this.onTouchEnd, { passive: false });
        var container = this.container.current;
        if (container) {
            // Add event listeners here due to https://github.com/facebook/react/issues/9809#issuecomment-414072263
            container.addEventListener('touchstart', this.onTouchStart, {
                passive: false,
            });
            container.addEventListener('mousedown', this.onMouseDown, {
                passive: false,
            });
        }
    };
    DraggableElement.prototype.componentDidUpdate = function (prevProps) {
        if (this.props.disabled && !prevProps.disabled) {
            this.touches = [];
        }
    };
    DraggableElement.prototype.render = function () {
        var _a = this.props, children = _a.children, className = _a.className;
        return (React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-draggable-element', className), ref: this.container, onMouseOver: this.onMouseOver, onMouseLeave: this.onMouseLeave }, children));
    };
    DraggableElement.defaultProps = {
        disabled: false,
        activationDistance: 30,
        useAnchor: true,
        rerender: true,
    };
    return DraggableElement;
}(React.Component));

var LineWrapper = function (_a) {
    var position = _a.position, className = _a.className, disabled = _a.disabled, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd, onLeave = _a.onLeave, onEnter = _a.onEnter, children = _a.children;
    return (React__default["default"].createElement(DraggableElement, { className: cn__default["default"]([
            'advanced-cropper-line-wrapper',
            position && "advanced-cropper-line-wrapper--".concat(position),
            disabled && "advanced-cropper-line-wrapper--disabled",
            className,
        ]), disabled: disabled, onMove: onDrag, onMoveEnd: onDragEnd, onLeave: onLeave, onEnter: onEnter, activationDistance: 0 },
        React__default["default"].createElement("div", { className: cn__default["default"]([
                'advanced-cropper-line-wrapper__content',
                position && "advanced-cropper-line-wrapper__content--".concat(position),
            ]) }, children)));
};

var SimpleLine = function (_a) {
    var _b, _c;
    var position = _a.position, hoverClassName = _a.hoverClassName, wrapperClassName = _a.wrapperClassName, defaultClassName = _a.defaultClassName, disabled = _a.disabled, onMove = _a.onMove, onMoveEnd = _a.onMoveEnd;
    var _d = tslib.__read(React.useState(false), 2), hover = _d[0], setHover = _d[1];
    var onEnter = function () {
        setHover(true);
    };
    var onLeave = function () {
        setHover(false);
    };
    return (React__default["default"].createElement(LineWrapper, { className: cn__default["default"]('advanced-cropper-simple-line-wrapper', wrapperClassName, (_b = {},
            _b["advanced-cropper-simple-line-wrapper--".concat(position)] = !!position,
            _b)), position: position, disabled: disabled, onDrag: onMove, onDragEnd: onMoveEnd, onLeave: onLeave, onEnter: onEnter },
        React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-simple-line', hover && 'advanced-cropper-simple-line--hover', defaultClassName, hover && hoverClassName, (_c = {},
                _c["advanced-cropper-simple-line--".concat(position)] = !!position,
                _c)) })));
};

var HandlerWrapper = function (_a) {
    var horizontalPosition = _a.horizontalPosition, verticalPosition = _a.verticalPosition, className = _a.className, disabled = _a.disabled, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd, onLeave = _a.onLeave, onEnter = _a.onEnter, children = _a.children, style = _a.style;
    var position = horizontalPosition || verticalPosition
        ? advancedCropper.getDirectionNames(horizontalPosition, verticalPosition).snakeCase
        : null;
    return (React__default["default"].createElement("div", { style: style, className: cn__default["default"](className, 'advanced-cropper-handler-wrapper', position && "advanced-cropper-handler-wrapper--".concat(position), disabled && 'advanced-cropper-handler-wrapper--disabled') },
        React__default["default"].createElement(DraggableElement, { className: 'advanced-cropper-handler-wrapper__draggable', disabled: disabled, onMove: onDrag, onMoveEnd: onDragEnd, onLeave: onLeave, onEnter: onEnter, activationDistance: 0 }, children)));
};

var SimpleHandler = function (_a) {
    var _b;
    var verticalPosition = _a.verticalPosition, horizontalPosition = _a.horizontalPosition, hoverClassName = _a.hoverClassName, wrapperClassName = _a.wrapperClassName, defaultClassName = _a.defaultClassName, wrapperStyle = _a.wrapperStyle, disabled = _a.disabled, onMove = _a.onMove, onMoveEnd = _a.onMoveEnd;
    var _c = tslib.__read(React.useState(false), 2), hover = _c[0], setHover = _c[1];
    var onEnter = function () {
        setHover(true);
    };
    var onLeave = function () {
        setHover(false);
    };
    return (React__default["default"].createElement(HandlerWrapper, { style: wrapperStyle, className: cn__default["default"]('advanced-cropper-simple-handler-wrapper', wrapperClassName, verticalPosition && "advanced-cropper-simple-handler-wrapper--".concat(verticalPosition), horizontalPosition && "advanced-cropper-simple-handler-wrapper--".concat(horizontalPosition), horizontalPosition &&
            verticalPosition &&
            "advanced-cropper-simple-handler-wrapper--".concat(horizontalPosition, "-").concat(verticalPosition), hover && 'advanced-cropper-simple-handler-wrapper--hover'), verticalPosition: verticalPosition, horizontalPosition: horizontalPosition, disabled: disabled, onDrag: onMove, onDragEnd: onMoveEnd, onLeave: onLeave, onEnter: onEnter },
        React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-simple-handler', hover && 'advanced-cropper-simple-handler--hover', defaultClassName, hover && hoverClassName, (_b = {},
                _b["advanced-cropper-simple-handler--".concat(verticalPosition)] = !!verticalPosition,
                _b["advanced-cropper-simple-handler--".concat(horizontalPosition)] = !!horizontalPosition,
                _b["advanced-cropper-simple-handler--".concat(horizontalPosition, "-").concat(verticalPosition)] = horizontalPosition && verticalPosition,
                _b)) })));
};

var HORIZONTAL_DIRECTIONS = ['east', 'west', null];
var VERTICAL_DIRECTIONS = ['south', 'north', null];
var BoundingBox = function (_a) {
    var style = _a.style, className = _a.className, children = _a.children, onResize = _a.onResize, onResizeEnd = _a.onResizeEnd, _b = _a.handlerComponent, handlerComponent = _b === void 0 ? SimpleHandler : _b, _c = _a.handlers, handlers = _c === void 0 ? {
        eastNorth: true,
        north: true,
        westNorth: true,
        west: true,
        westSouth: true,
        south: true,
        eastSouth: true,
        east: true,
    } : _c, _d = _a.handlerClassNames, handlerClassNames = _d === void 0 ? {} : _d, _e = _a.handlerWrapperClassNames, handlerWrapperClassNames = _e === void 0 ? {} : _e, _f = _a.lines, lines = _f === void 0 ? {
        west: true,
        north: true,
        east: true,
        south: true,
    } : _f, _g = _a.lineComponent, lineComponent = _g === void 0 ? SimpleLine : _g, _h = _a.lineClassNames, lineClassNames = _h === void 0 ? {} : _h, _j = _a.lineWrapperClassNames, lineWrapperClassNames = _j === void 0 ? {} : _j, _k = _a.disabled, disabled = _k === void 0 ? false : _k, _l = _a.reference, reference = _l === void 0 ? null : _l;
    var _m = tslib.__read(React.useState(null), 2), lastReference = _m[0], setLastReference = _m[1];
    var points = React.useMemo(function () {
        var result = [];
        HORIZONTAL_DIRECTIONS.forEach(function (hDirection) {
            VERTICAL_DIRECTIONS.forEach(function (vDirection) {
                if (hDirection !== vDirection) {
                    var _a = advancedCropper.getDirectionNames(hDirection, vDirection), snakeCase = _a.snakeCase, camelCase = _a.camelCase;
                    if (snakeCase && camelCase) {
                        result.push({
                            name: camelCase,
                            className: snakeCase,
                            verticalPosition: vDirection,
                            horizontalPosition: hDirection,
                        });
                    }
                }
            });
        });
        return result;
    }, []);
    var lineNodes = React.useMemo(function () {
        var result = [];
        points.forEach(function (point) {
            if (advancedCropper.isCardinalDirection(point.name) && (advancedCropper.isObject(lines) ? lines[point.name] : lines)) {
                result.push({
                    name: point.name,
                    component: lineComponent,
                    className: cn__default["default"](lineClassNames.default, lineClassNames[point.name], disabled && lineClassNames.disabled),
                    wrapperClassName: cn__default["default"]("advanced-cropper-bounding-box__line", "advanced-cropper-bounding-box__line--".concat(point.name), lineWrapperClassNames.default, lineWrapperClassNames[point.name], disabled && lineWrapperClassNames.disabled),
                    hoverClassName: lineClassNames.hover,
                    verticalPosition: point.verticalPosition,
                    horizontalPosition: point.horizontalPosition,
                    disabled: disabled,
                });
            }
        });
        return result;
    }, [points, lines, lineComponent, lineClassNames, lineWrapperClassNames, disabled]);
    var handlerNodes = React.useMemo(function () {
        var result = [];
        points.forEach(function (point) {
            if (advancedCropper.isObject(handlers) ? handlers[point.name] : handlers) {
                result.push({
                    name: point.name,
                    component: handlerComponent,
                    className: cn__default["default"](handlerClassNames.default, handlerClassNames[point.name]),
                    containerClassName: cn__default["default"]("advanced-cropper-bounding-box__handler-wrapper", "advanced-cropper-bounding-box__handler-wrapper--".concat(point.className)),
                    wrapperClassName: cn__default["default"]("advanced-cropper-bounding-box__handler", "advanced-cropper-bounding-box__handler--".concat(point.className), handlerWrapperClassNames.default, handlerWrapperClassNames[point.name]),
                    hoverClassName: handlerClassNames.hover,
                    verticalPosition: point.verticalPosition,
                    horizontalPosition: point.horizontalPosition,
                    disabled: disabled,
                });
            }
        });
        return result;
    }, [points, handlers, handlerComponent, handlerClassNames, handlerWrapperClassNames, disabled]);
    var onHandlerMove = function (horizontalPosition, verticalPosition) {
        return function (_a, nativeEvent) {
            var left = _a.left, top = _a.top;
            var directions = {
                left: left,
                top: top,
            };
            var respectDirection;
            if (!verticalPosition && horizontalPosition) {
                respectDirection = 'width';
            }
            else if (verticalPosition && !horizontalPosition) {
                respectDirection = 'height';
            }
            if (!disabled) {
                if (onResize) {
                    var anchor = advancedCropper.getDirectionNames(horizontalPosition, verticalPosition).camelCase;
                    if (anchor) {
                        onResize(anchor, directions, {
                            reference: lastReference || reference,
                            preserveAspectRatio: nativeEvent && nativeEvent.shiftKey,
                            respectDirection: respectDirection,
                            compensate: true,
                        });
                    }
                }
                if (!lastReference) {
                    setLastReference(reference);
                }
            }
        };
    };
    var onHandlerMoveEnd = function () {
        onResizeEnd === null || onResizeEnd === void 0 ? void 0 : onResizeEnd();
        setLastReference(null);
    };
    return (React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-bounding-box', className), style: style },
        children,
        React__default["default"].createElement("div", null, lineNodes.map(function (line) { return (React__default["default"].createElement(line.component, { key: line.name, defaultClassName: line.className, hoverClassName: line.hoverClassName, wrapperClassName: line.wrapperClassName, position: line.name, disabled: line.disabled, onMove: onHandlerMove(line.horizontalPosition, line.verticalPosition), onMoveEnd: onHandlerMoveEnd })); })),
        React__default["default"].createElement("div", null, handlerNodes.map(function (handler) {
            var handlerElement = (React__default["default"].createElement(handler.component, { defaultClassName: handler.className, hoverClassName: handler.hoverClassName, wrapperClassName: handler.wrapperClassName, horizontalPosition: handler.horizontalPosition, verticalPosition: handler.verticalPosition, disabled: handler.disabled, onMove: onHandlerMove(handler.horizontalPosition, handler.verticalPosition), onMoveEnd: onHandlerMoveEnd }));
            return (React__default["default"].createElement("div", { key: handler.name, className: handler.containerClassName }, handlerElement));
        }))));
};

var StencilOverlay = function (_a) {
    var className = _a.className, children = _a.children;
    return React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-stencil-overlay', className) }, children);
};

function useTransition(transitions) {
    if (transitions === void 0) { transitions = null; }
    var animation = React.useRef(new advancedCropper.Animation());
    var _a = tslib.__read(React.useState(false), 2), active = _a[0], setActive = _a[1];
    return [
        function (callback) {
            if (transitions && transitions.active) {
                animation.current.start(tslib.__assign(tslib.__assign({}, transitions), { onStart: function () {
                        setActive(true);
                    }, onProgress: function (progress) {
                        callback(progress);
                    }, onStop: function () {
                        setActive(false);
                    } }));
            }
            else if (!animation.current.active) {
                callback(1);
            }
        },
        active,
    ];
}

var ArtificialTransition = function (_a) {
    var className = _a.className, transitions = _a.transitions, children = _a.children, values = tslib.__rest(_a, ["className", "transitions", "children"]);
    var root = React.useRef(null);
    var transitionValues = React.useRef(values);
    var _b = tslib.__read(React.useState(values), 2), rememberedValues = _b[0], setRememberedValues = _b[1];
    var _c = tslib.__read(useTransition(transitions), 2), runTransitions = _c[0], transitionsActive = _c[1];
    React.useLayoutEffect(function () {
        if (!advancedCropper.deepCompare(rememberedValues, values)) {
            setRememberedValues(values);
            var startValues_1 = transitionsActive
                ? tslib.__assign({}, transitionValues.current) : rememberedValues;
            runTransitions(function (progress) {
                var properties = ['left', 'top', 'height', 'width'];
                properties.forEach(function (property) {
                    var desiredValue = values[property];
                    var startValue = startValues_1[property];
                    transitionValues.current[property] =
                        advancedCropper.isNumber(startValue) && advancedCropper.isNumber(desiredValue)
                            ? startValue + (desiredValue - startValue) * progress
                            : desiredValue;
                });
                if (root.current) {
                    root.current.style.width = "".concat(transitionValues.current.width, "px");
                    root.current.style.height = "".concat(transitionValues.current.height, "px");
                    root.current.style.transform = "translate3d(".concat(transitionValues.current.left, "px, ").concat(transitionValues.current.top, "px, 0px)");
                }
            });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [rememberedValues, transitionsActive, values.width, values.height, values.top, values.left]);
    var currentValues = transitionsActive ? transitionValues.current : values;
    var rootStyle = {
        left: 0,
        top: 0,
        width: "".concat(currentValues.width, "px"),
        height: "".concat(currentValues.height, "px"),
        transform: "translate3d(".concat(currentValues.left, "px, ").concat(currentValues.top, "px, 0px)"),
    };
    return (React__default["default"].createElement("div", { ref: root, className: cn__default["default"]('advanced-cropper-artificial-transition', className), style: rootStyle }, children));
};

var StencilWrapper = function (_a) {
    var className = _a.className, transitions = _a.transitions, width = _a.width, height = _a.height, left = _a.left, top = _a.top, children = _a.children;
    return (React__default["default"].createElement(ArtificialTransition, { className: cn__default["default"]('advanced-cropper-stencil-wrapper', className), transitions: transitions, width: width, height: height, top: top, left: left }, children));
};

var StencilGrid = function (_a) {
    var _b = _a.columns, columns = _b === void 0 ? 3 : _b, _c = _a.rows, rows = _c === void 0 ? 3 : _c, _d = _a.visible, visible = _d === void 0 ? false : _d, className = _a.className;
    var nodes = [];
    var _e = tslib.__read(React.useState(columns), 2), currentColumns = _e[0], setCurrentColumns = _e[1];
    var _f = tslib.__read(React.useState(rows), 2), currentRows = _f[0], setCurrentRows = _f[1];
    useUpdateEffect(function () {
        if (visible) {
            setCurrentRows(rows);
            setCurrentColumns(columns);
        }
    }, [visible, columns, rows]);
    for (var i = 0; i < currentRows; i++) {
        var cells = [];
        for (var j = 0; j < currentColumns; j++) {
            cells.push(React__default["default"].createElement("div", { key: j, className: cn__default["default"]('advanced-cropper-stencil-grid__cell', i === 0 && 'advanced-cropper-stencil-grid__cell--top', i === currentRows - 1 && 'advanced-cropper-stencil-grid__cell--bottom', j === 0 && 'advanced-cropper-stencil-grid__cell--left', j === currentColumns - 1 && 'advanced-cropper-stencil-grid__cell--right') }));
        }
        nodes.push(React__default["default"].createElement("div", { key: i, className: 'advanced-cropper-stencil-grid__row' }, cells));
    }
    return (React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-stencil-grid', visible && 'advanced-cropper-stencil-grid--visible', className) }, nodes));
};

var RectangleStencil = React.forwardRef(function (_a, ref) {
    var cropper = _a.cropper, coordinates = _a.coordinates, aspectRatio = _a.aspectRatio, minAspectRatio = _a.minAspectRatio, maxAspectRatio = _a.maxAspectRatio, _b = _a.handlerComponent, handlerComponent = _b === void 0 ? SimpleHandler : _b, _c = _a.handlers, handlers = _c === void 0 ? {
        eastNorth: true,
        north: true,
        westNorth: true,
        west: true,
        westSouth: true,
        south: true,
        eastSouth: true,
        east: true,
    } : _c, _d = _a.handlerClassNames, handlerClassNames = _d === void 0 ? {} : _d, _e = _a.handlerWrapperClassNames, handlerWrapperClassNames = _e === void 0 ? {} : _e, _f = _a.lines, lines = _f === void 0 ? {
        west: true,
        north: true,
        east: true,
        south: true,
    } : _f, _g = _a.lineComponent, lineComponent = _g === void 0 ? SimpleLine : _g, _h = _a.lineClassNames, lineClassNames = _h === void 0 ? {} : _h, _j = _a.lineWrapperClassNames, lineWrapperClassNames = _j === void 0 ? {} : _j, _k = _a.resizable, resizable = _k === void 0 ? true : _k, _l = _a.movable, movable = _l === void 0 ? true : _l, grid = _a.grid, gridClassName = _a.gridClassName, className = _a.className, movingClassName = _a.movingClassName, resizingClassName = _a.resizingClassName, previewClassName = _a.previewClassName, boundingBoxClassName = _a.boundingBoxClassName, overlayClassName = _a.overlayClassName, draggableAreaClassName = _a.draggableAreaClassName;
    var state = cropper.getState();
    var transitions = cropper.getTransitions();
    var interactions = cropper.getInteractions();
    React.useImperativeHandle(ref, function () { return ({
        aspectRatio: advancedCropper.createAspectRatio(aspectRatio || {
            minimum: minAspectRatio,
            maximum: maxAspectRatio,
        }),
    }); });
    var onMove = function (directions) {
        if (cropper && movable) {
            cropper.moveCoordinates(directions);
        }
    };
    var onMoveEnd = function () {
        if (cropper) {
            cropper.moveCoordinatesEnd();
        }
    };
    var onResize = function (anchor, directions, options) {
        if (cropper && resizable) {
            cropper.resizeCoordinates(anchor, directions, options);
        }
    };
    var onResizeEnd = function () {
        if (cropper) {
            cropper.resizeCoordinatesEnd();
        }
    };
    var _m = coordinates
        ? advancedCropper.isFunction(coordinates)
            ? coordinates(state)
            : coordinates
        : advancedCropper.getStencilCoordinates(state), width = _m.width, height = _m.height, left = _m.left, top = _m.top;
    return (state && (React__default["default"].createElement(StencilWrapper, { className: cn__default["default"]('advanced-cropper-rectangle-stencil', className, interactions.moveCoordinates && movingClassName, interactions.resizeCoordinates && resizingClassName, {
            'advanced-cropper-rectangle-stencil--movable': movable,
            'advanced-cropper-rectangle-stencil--moving': interactions.moveCoordinates,
            'advanced-cropper-rectangle-stencil--resizable': resizable,
            'advanced-cropper-rectangle-stencil--resizing': interactions.resizeCoordinates,
        }), width: width, height: height, left: left, top: top, transitions: transitions },
        React__default["default"].createElement(BoundingBox, { reference: state.coordinates, className: cn__default["default"](boundingBoxClassName, 'advanced-cropper-rectangle-stencil__bounding-box'), handlers: handlers, handlerComponent: handlerComponent, handlerClassNames: handlerClassNames, handlerWrapperClassNames: handlerWrapperClassNames, lines: lines, lineComponent: lineComponent, lineClassNames: lineClassNames, lineWrapperClassNames: lineWrapperClassNames, onResize: onResize, onResizeEnd: onResizeEnd, disabled: !resizable },
            React__default["default"].createElement(DraggableElement, { disabled: !movable, onMove: onMove, onMoveEnd: onMoveEnd, className: cn__default["default"]('advanced-cropper-rectangle-stencil__draggable-area', draggableAreaClassName) },
                React__default["default"].createElement(StencilOverlay, { className: cn__default["default"]('advanced-cropper-rectangle-stencil__overlay', overlayClassName) },
                    grid && (React__default["default"].createElement(StencilGrid, { visible: cropper.hasInteractions(), columns: interactions.transformImage.rotate ? 9 : 3, rows: interactions.transformImage.rotate ? 9 : 3, className: cn__default["default"]('advanced-cropper-rectangle-stencil__grid', gridClassName) })),
                    React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-rectangle-stencil__preview', previewClassName) })))))));
});
RectangleStencil.displayName = 'RectangleStencil';

function useRotateImageOptions(rotateImage) {
    return React.useMemo(function () {
        return advancedCropper.getOptions(rotateImage, {
            touch: true,
        }, {
            touch: false,
        });
    }, [rotateImage]);
}

function useScaleImageOptions(scaleImage) {
    return React.useMemo(function () {
        return advancedCropper.getOptions(scaleImage, {
            touch: true,
            wheel: {
                ratio: 0.1,
            },
        }, {
            touch: false,
            wheel: false,
        });
    }, [scaleImage]);
}

function useMoveImageOptions(moveImage) {
    return React.useMemo(function () {
        return advancedCropper.getOptions(moveImage, {
            touch: true,
            mouse: true,
        }, {
            touch: false,
            mouse: false,
        });
    }, [moveImage]);
}

var TransformableImageEvent = /** @class */ (function () {
    function TransformableImageEvent(_a) {
        var active = _a.active;
        this.active = active;
        this.defaultPrevented = false;
    }
    TransformableImageEvent.prototype.preventDefault = function () {
        this.defaultPrevented = true;
    };
    return TransformableImageEvent;
}());
var TransformableImage = /** @class */ (function (_super) {
    tslib.__extends(TransformableImage, _super);
    function TransformableImage(props) {
        var _this = _super.call(this, props) || this;
        _this.processMove = function (newTouches) {
            var _a = _this.props, onTransform = _a.onTransform, touchScale = _a.touchScale, touchMove = _a.touchMove, touchRotate = _a.touchRotate;
            var container = _this.container.current;
            if (container && onTransform) {
                onTransform(advancedCropper.touchesToImageTransform(newTouches, _this.touches, container, {
                    scale: touchScale,
                    rotate: touchRotate,
                    move: touchMove,
                }));
                _this.touches = newTouches;
            }
        };
        _this.processEnd = function () {
            var onTransformEnd = _this.props.onTransformEnd;
            if (_this.transforming) {
                _this.transforming = false;
                if (onTransformEnd) {
                    onTransformEnd();
                }
            }
        };
        _this.processStart = function () {
            _this.transforming = true;
            _this.debouncedProcessEnd.clear();
        };
        _this.processEvent = function (nativeEvent) {
            var _a = _this.props, onEvent = _a.onEvent, disabled = _a.disabled;
            var transformEvent = new TransformableImageEvent({ active: _this.transforming });
            if (onEvent) {
                onEvent(transformEvent, nativeEvent);
            }
            else {
                nativeEvent.preventDefault();
                nativeEvent.stopPropagation();
            }
            return !disabled && !transformEvent.defaultPrevented;
        };
        _this.onWheel = function (event) {
            var _a = _this.props, onTransform = _a.onTransform, wheelScale = _a.wheelScale;
            var container = _this.container.current;
            if (wheelScale) {
                if (_this.processEvent(event)) {
                    _this.processStart();
                    if (onTransform && container) {
                        onTransform(advancedCropper.wheelEventToImageTransform(event, container, wheelScale === true ? 0.1 : wheelScale.ratio));
                    }
                    if (!_this.touches.length) {
                        _this.debouncedProcessEnd();
                    }
                }
            }
        };
        _this.onTouchStart = function (event) {
            var _a = _this.props, touchMove = _a.touchMove, touchScale = _a.touchScale, touchRotate = _a.touchRotate;
            if (event.cancelable && (touchMove || ((touchScale || touchRotate) && event.touches.length > 1))) {
                if (_this.processEvent(event)) {
                    var container = _this.container.current;
                    if (container) {
                        var _b = container.getBoundingClientRect(), left_1 = _b.left, top_1 = _b.top, bottom_1 = _b.bottom, right_1 = _b.right;
                        _this.touches = Array.from(event.touches).filter(function (touch) {
                            return touch.clientX > left_1 &&
                                touch.clientX < right_1 &&
                                touch.clientY > top_1 &&
                                touch.clientY < bottom_1;
                        });
                    }
                }
            }
        };
        _this.onTouchEnd = function (event) {
            if (event.touches.length === 0) {
                _this.touches = [];
                _this.processEnd();
            }
        };
        _this.onTouchMove = function (event) {
            if (_this.touches.length) {
                var touches = tslib.__spreadArray([], tslib.__read(event.touches), false).filter(function (touch) {
                    return !touch.identifier ||
                        _this.touches.find(function (anotherTouch) { return anotherTouch.identifier === touch.identifier; });
                });
                if (_this.processEvent(event)) {
                    _this.processMove(touches);
                    _this.processStart();
                }
            }
        };
        _this.onMouseDown = function (event) {
            var mouseMove = _this.props.mouseMove;
            if (mouseMove && 'buttons' in event && event.buttons === 1) {
                if (_this.processEvent(event)) {
                    var touch = {
                        clientX: event.clientX,
                        clientY: event.clientY,
                    };
                    _this.touches = [touch];
                    _this.processStart();
                }
            }
        };
        _this.onMouseMove = function (event) {
            if (_this.touches.length) {
                if (_this.processEvent(event)) {
                    _this.processMove([
                        {
                            clientX: event.clientX,
                            clientY: event.clientY,
                        },
                    ]);
                }
            }
        };
        _this.onMouseUp = function () {
            _this.touches = [];
            _this.processEnd();
        };
        _this.transforming = false;
        _this.touches = [];
        _this.anchor = {
            left: 0,
            top: 0,
        };
        _this.container = React.createRef();
        _this.debouncedProcessEnd = advancedCropper.debounce(_this.processEnd, props.timeout);
        return _this;
    }
    TransformableImage.prototype.shouldComponentUpdate = function () {
        return true;
    };
    TransformableImage.prototype.componentWillUnmount = function () {
        window.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('touchmove', this.onTouchMove);
        window.removeEventListener('touchend', this.onTouchEnd);
        var container = this.container.current;
        if (container) {
            container.removeEventListener('touchstart', this.onTouchStart);
            container.removeEventListener('mousedown', this.onMouseDown);
            container.removeEventListener('wheel', this.onWheel);
        }
    };
    TransformableImage.prototype.componentDidMount = function () {
        window.addEventListener('mouseup', this.onMouseUp, { passive: false });
        window.addEventListener('mousemove', this.onMouseMove, { passive: false });
        window.addEventListener('touchmove', this.onTouchMove, { passive: false });
        window.addEventListener('touchend', this.onTouchEnd, { passive: false });
        var container = this.container.current;
        if (container) {
            // Add event listeners here due to https://github.com/facebook/react/issues/9809#issuecomment-414072263
            container.addEventListener('touchstart', this.onTouchStart, {
                passive: false,
            });
            container.addEventListener('mousedown', this.onMouseDown, {
                passive: false,
            });
            container.addEventListener('wheel', this.onWheel, {
                passive: false,
            });
        }
    };
    TransformableImage.prototype.render = function () {
        var _a = this.props, className = _a.className, children = _a.children, style = _a.style;
        return (React__default["default"].createElement("div", { className: className, style: style, ref: this.container }, children));
    };
    TransformableImage.defaultProps = {
        touchMove: true,
        mouseMove: true,
        touchScale: true,
        touchRotate: false,
        wheelScale: true,
        timeout: 500,
    };
    return TransformableImage;
}(React.Component));

var CropperBackgroundWrapper = function (_a) {
    var _b = _a.scaleImage, scaleImage = _b === void 0 ? true : _b, _c = _a.moveImage, moveImage = _c === void 0 ? true : _c, _d = _a.rotateImage, rotateImage = _d === void 0 ? false : _d, children = _a.children, className = _a.className, style = _a.style, cropper = _a.cropper, timeout = _a.timeout;
    var transitions = cropper.getTransitions();
    var rotateImageOptions = useRotateImageOptions(rotateImage);
    var scaleImageOptions = useScaleImageOptions(scaleImage);
    var moveImageOptions = useMoveImageOptions(moveImage);
    return (React__default["default"].createElement(TransformableImage, { className: className, style: style, onTransform: cropper.transformImage, onTransformEnd: cropper.transformImageEnd, touchMove: moveImageOptions.touch, mouseMove: moveImageOptions.mouse, touchScale: scaleImageOptions.touch, wheelScale: scaleImageOptions.wheel, touchRotate: rotateImageOptions.touch, disabled: transitions.active, timeout: timeout }, children));
};

var AbstractCropperComponent = function (props, ref) {
    var style = props.style, className = props.className, _a = props.stencilComponent, stencilComponent = _a === void 0 ? RectangleStencil : _a, _b = props.stencilConstraints, stencilConstraints = _b === void 0 ? advancedCropper.defaultStencilConstraints : _b, _c = props.stencilProps, stencilProps = _c === void 0 ? {} : _c, _d = props.wrapperComponent, wrapperComponent = _d === void 0 ? CropperWrapper : _d, _e = props.wrapperProps, wrapperProps = _e === void 0 ? {} : _e, _f = props.backgroundComponent, backgroundComponent = _f === void 0 ? CropperBackgroundImage : _f, _g = props.backgroundProps, backgroundProps = _g === void 0 ? {} : _g, backgroundClassName = props.backgroundClassName, _h = props.backgroundWrapperComponent, backgroundWrapperComponent = _h === void 0 ? CropperBackgroundWrapper : _h, _j = props.backgroundWrapperProps, backgroundWrapperProps = _j === void 0 ? {} : _j, _k = props.boundaryComponent, boundaryComponent = _k === void 0 ? StretchableBoundary : _k, boundaryProps = props.boundaryProps, boundaryClassName = props.boundaryClassName, _l = props.canvas, canvas = _l === void 0 ? true : _l, _m = props.crossOrigin, crossOrigin = _m === void 0 ? true : _m, settings = props.settings, parameters = tslib.__rest(props, ["style", "className", "stencilComponent", "stencilConstraints", "stencilProps", "wrapperComponent", "wrapperProps", "backgroundComponent", "backgroundProps", "backgroundClassName", "backgroundWrapperComponent", "backgroundWrapperProps", "boundaryComponent", "boundaryProps", "boundaryClassName", "canvas", "crossOrigin", "settings"]);
    var stencilRef = React.useRef(null);
    var _o = useAbstractCropper(function () { return (tslib.__assign(tslib.__assign({}, parameters), { crossOrigin: crossOrigin, stencilProps: stencilProps, canvas: canvas, settings: tslib.__assign(tslib.__assign({}, settings), stencilConstraints(settings, tslib.__assign(tslib.__assign({}, stencilProps), stencilRef.current))) })); }), cropper = _o.cropper, image = _o.image, refs = _o.refs;
    var StencilComponent = stencilComponent;
    var WrapperComponent = wrapperComponent;
    var BackgroundWrapperComponent = backgroundWrapperComponent;
    var BackgroundComponent = backgroundComponent;
    var BoundaryComponent = boundaryComponent;
    React.useImperativeHandle(ref, function () { return cropper; });
    var deprecatedWrapperProps = {
        loading: cropper.isLoading(),
        loaded: cropper.isLoaded(),
    };
    return (React__default["default"].createElement(WrapperComponent, tslib.__assign({}, wrapperProps, { className: cn__default["default"]('advanced-cropper', className), cropper: cropper, style: style }, deprecatedWrapperProps),
        React__default["default"].createElement(BoundaryComponent, tslib.__assign({}, boundaryProps, { ref: refs.boundary, className: cn__default["default"]('advanced-cropper__boundary', boundaryClassName) }),
            React__default["default"].createElement(BackgroundWrapperComponent, tslib.__assign({}, backgroundWrapperProps, { cropper: cropper, className: 'advanced-cropper__background-wrapper' }),
                cropper.getState() && (React__default["default"].createElement(BackgroundComponent, tslib.__assign({}, backgroundProps, { ref: refs.image, crossOrigin: crossOrigin, cropper: cropper, className: cn__default["default"]('advanced-cropper__background', backgroundClassName) }))),
                React__default["default"].createElement(StencilComponent, tslib.__assign({}, stencilProps, { ref: stencilRef, cropper: cropper, image: image }))),
            canvas && React__default["default"].createElement(CropperCanvas, { ref: refs.canvas }))));
};
var AbstractCropper = createCropper(AbstractCropperComponent);

var defaultSettings = [
    'transformImage',
    'moveCoordinates',
    'resizeCoordinates',
    'defaultCoordinates',
    'defaultVisibleArea',
    'areaPositionRestrictions',
    'areaSizeRestrictions',
    'sizeRestrictions',
    'positionRestrictions',
    'aspectRatio',
    'minWidth',
    'minHeight',
    'maxWidth',
    'maxHeight',
    'defaultSize',
    'defaultPosition',
    'defaultTransforms',
    'imageRestriction',
    'priority',
];

function useAbstractCropperProps(props, settings) {
    if (settings === void 0) { settings = defaultSettings; }
    var result = { settings: {}, props: {} };
    Object.keys(props).forEach(function (key) {
        if (settings.some(function (setting) { return setting === key; })) {
            result.settings[key] = props[key];
        }
        else {
            result.props[key] = props[key];
        }
    });
    return result;
}

var FixedCropper = React.forwardRef(function (props, ref) {
    var cropperProps = useAbstractCropperProps(props, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(defaultSettings), false), ['stencilSize'], false));
    return (React__default["default"].createElement(AbstractCropper, tslib.__assign({ postProcess: stencilSize.fixedStencil, stencilConstraints: stencilSize.fixedStencilConstraints }, cropperProps.props, { settings: tslib.__assign(tslib.__assign({ defaultSize: stencilSize.defaultSize, aspectRatio: stencilSize.aspectRatio, sizeRestrictions: defaults.withDefaultSizeRestrictions(stencilSize.sizeRestrictions) }, cropperProps.settings), { transformImage: tslib.__assign(tslib.__assign({}, cropperProps.settings.transformImage), { adjustStencil: false }) }), ref: ref })));
});
FixedCropper.displayName = 'FixedCropper';

var Cropper = React.forwardRef(function (props, ref) {
    var cropperProps = useAbstractCropperProps(props);
    var intrinsicProps = cropperProps.props;
    // Process the deprecated properties
    var _a = cropperProps.settings, stencilSize = _a.stencilSize, autoZoom = _a.autoZoom, actualSettings = tslib.__rest(_a, ["stencilSize", "autoZoom"]);
    var deprecationWarning = useDeprecationWarning();
    if (!advancedCropper.isUndefined(autoZoom)) {
        if (intrinsicProps.postProcess || stencilSize) {
            deprecationWarning("prop 'autoZoom' is deprecated now and will be removed, use 'postProcess' prop to pass your auto zoom function.");
        }
        else {
            deprecationWarning("prop 'autoZoom' is deprecated now and will be removed, use 'postProcess' prop to pass your auto zoom function. The 'postProcess' automatically set to 'hybridAutoZoom'");
            intrinsicProps.postProcess = hybridStencilAutoZoom;
        }
    }
    if (!advancedCropper.isUndefined(stencilSize)) {
        deprecationWarning("prop 'stencilSize' is deprecated for <Cropper/> component now and will be removed, use <FixedCropper/> component instead.");
        return (React__default["default"].createElement(FixedCropper, tslib.__assign({ ref: ref, stencilSize: stencilSize }, actualSettings, intrinsicProps)));
    }
    return React__default["default"].createElement(AbstractCropper, tslib.__assign({}, intrinsicProps, { ref: ref, settings: actualSettings }));
});
Cropper.displayName = 'CropperComponent';

var CircleStencil = React.forwardRef(function (_a, ref) {
    var cropper = _a.cropper, coordinates = _a.coordinates, _b = _a.handlerComponent, handlerComponent = _b === void 0 ? SimpleHandler : _b, _c = _a.handlers, handlers = _c === void 0 ? {
        eastNorth: true,
        westNorth: true,
        westSouth: true,
        eastSouth: true,
    } : _c, _d = _a.handlerClassNames, handlerClassNames = _d === void 0 ? {} : _d, _e = _a.handlerWrapperClassNames, handlerWrapperClassNames = _e === void 0 ? {} : _e, _f = _a.lines, lines = _f === void 0 ? {
        west: true,
        north: true,
        east: true,
        south: true,
    } : _f, _g = _a.lineComponent, lineComponent = _g === void 0 ? SimpleLine : _g, _h = _a.lineClassNames, lineClassNames = _h === void 0 ? {} : _h, _j = _a.lineWrapperClassNames, lineWrapperClassNames = _j === void 0 ? {} : _j, _k = _a.resizable, resizable = _k === void 0 ? true : _k, _l = _a.movable, movable = _l === void 0 ? true : _l, grid = _a.grid, gridClassName = _a.gridClassName, className = _a.className, movingClassName = _a.movingClassName, resizingClassName = _a.resizingClassName, previewClassName = _a.previewClassName, boundingBoxClassName = _a.boundingBoxClassName, overlayClassName = _a.overlayClassName, draggableAreaClassName = _a.draggableAreaClassName;
    var state = cropper.getState();
    var transitions = cropper.getTransitions();
    var interactions = cropper.getInteractions();
    React.useImperativeHandle(ref, function () { return ({
        aspectRatio: 1,
        boundingBox: 'circle',
    }); });
    var onMove = function (directions) {
        if (cropper && movable) {
            cropper.moveCoordinates(directions);
        }
    };
    var onMoveEnd = function () {
        if (cropper) {
            cropper.moveCoordinatesEnd();
        }
    };
    var onResize = function (anchor, directions, options) {
        if (cropper && resizable) {
            cropper.resizeCoordinates(anchor, directions, options);
        }
    };
    var onResizeEnd = function () {
        if (cropper) {
            cropper.resizeCoordinatesEnd();
        }
    };
    var _m = coordinates
        ? advancedCropper.isFunction(coordinates)
            ? coordinates(state)
            : coordinates
        : advancedCropper.getStencilCoordinates(state), width = _m.width, height = _m.height, left = _m.left, top = _m.top;
    return (state && (React__default["default"].createElement(StencilWrapper, { className: cn__default["default"]('advanced-cropper-circle-stencil', className, interactions.moveCoordinates && movingClassName, interactions.resizeCoordinates && resizingClassName, {
            'advanced-cropper-circle-stencil--movable': movable,
            'advanced-cropper-circle-stencil--moving': interactions.moveCoordinates,
            'advanced-cropper-circle-stencil--resizable': resizable,
            'advanced-cropper-circle-stencil--resizing': interactions.resizeCoordinates,
        }), width: width, height: height, left: left, top: top, transitions: transitions },
        React__default["default"].createElement(BoundingBox, { reference: state.coordinates, className: cn__default["default"](boundingBoxClassName, 'advanced-cropper-circle-stencil__bounding-box'), handlers: handlers, handlerComponent: handlerComponent, handlerClassNames: handlerClassNames, handlerWrapperClassNames: handlerWrapperClassNames, lines: lines, lineComponent: lineComponent, lineClassNames: lineClassNames, lineWrapperClassNames: lineWrapperClassNames, onResize: onResize, onResizeEnd: onResizeEnd, disabled: !resizable },
            React__default["default"].createElement(DraggableElement, { disabled: !movable, onMove: onMove, onMoveEnd: onMoveEnd, className: cn__default["default"]('advanced-cropper-circle-stencil__draggable-area', draggableAreaClassName) },
                React__default["default"].createElement(StencilOverlay, { className: cn__default["default"]('advanced-cropper-circle-stencil__overlay', overlayClassName) },
                    grid && (React__default["default"].createElement(StencilGrid, { visible: cropper.hasInteractions(), columns: interactions.transformImage.rotate ? 9 : 3, rows: interactions.transformImage.rotate ? 9 : 3, className: cn__default["default"]('advanced-cropper-circle-stencil__grid', gridClassName) })),
                    React__default["default"].createElement("div", { className: cn__default["default"]('advanced-cropper-circle-stencil__preview', previewClassName) })))))));
});
CircleStencil.displayName = 'CircleStencil';

var CropperSource = React.forwardRef(function (_a, ref) {
    var src = _a.src, _b = _a.crossOrigin, crossOrigin = _b === void 0 ? true : _b, props = tslib.__rest(_a, ["src", "crossOrigin"]);
    return src ? (React__default["default"].createElement("img", tslib.__assign({ key: src, ref: ref, src: src, className: cn__default["default"]('advanced-cropper-source'), crossOrigin: crossOrigin === true ? 'anonymous' : crossOrigin || undefined }, props))) : null;
});
CropperSource.displayName = 'CropperSource';

var CropperPreviewWrapper = function (_a) {
    var children = _a.children, cropper = _a.cropper, className = _a.className, style = _a.style;
    return (React__default["default"].createElement("div", { className: cn__default["default"](className, 'cropper-preview-wrapper'), style: style },
        React__default["default"].createElement(CropperFade, { visible: cropper === null || cropper === void 0 ? void 0 : cropper.isLoaded(), className: 'cropper-preview-wrapper__fade' }, children)));
};

var CropperPreviewBackground = function (_a) {
    var className = _a.className, cropper = _a.cropper, _b = _a.crossOrigin, crossOrigin = _b === void 0 ? true : _b, size = _a.size, style = _a.style;
    var state = cropper.getState();
    var transitions = cropper.getTransitions();
    var image = cropper.getImage();
    var transformStyles = size && image && (state === null || state === void 0 ? void 0 : state.coordinates) ? advancedCropper.getPreviewStyle(image, state, size, transitions) : {};
    var src = image ? image.src : undefined;
    return src ? (React__default["default"].createElement("img", { key: src, className: cn__default["default"]('advanced-cropper-background-image', className), src: src, crossOrigin: crossOrigin === true ? 'anonymous' : crossOrigin || undefined, style: tslib.__assign(tslib.__assign({}, transformStyles), style), onMouseDown: preventDefault })) : null;
};

var CropperPreview = React.forwardRef(function (_a, ref) {
    var _b, _c, _d, _e;
    var className = _a.className, contentClassName = _a.contentClassName, _f = _a.state, state = _f === void 0 ? null : _f, _g = _a.image, image = _g === void 0 ? null : _g, _h = _a.transitions, transitions = _h === void 0 ? null : _h, _j = _a.backgroundComponent, backgroundComponent = _j === void 0 ? CropperPreviewBackground : _j, backgroundProps = _a.backgroundProps, backgroundClassName = _a.backgroundClassName, _k = _a.boundaryComponent, boundaryComponent = _k === void 0 ? StretchableBoundary : _k, boundaryProps = _a.boundaryProps, boundaryClassName = _a.boundaryClassName, _l = _a.wrapperComponent, wrapperComponent = _l === void 0 ? CropperPreviewWrapper : _l, wrapperProps = _a.wrapperProps, _m = _a.loaded, loaded = _m === void 0 ? true : _m, _o = _a.loading, loading = _o === void 0 ? false : _o, style = _a.style, cropper = _a.cropper;
    var rerender = useForceRerender();
    var boundaryRef = React.useRef(null);
    var instance = cropper || {
        current: {
            getState: function () { return state; },
            getTransitions: function () { return transitions; },
            getImage: function () { return image; },
            isLoaded: function () { return loaded; },
            isLoading: function () { return loading; },
        },
    };
    var _p = tslib.__read(React.useState(null), 2), size = _p[0], setSize = _p[1];
    var coordinates = (_c = (_b = instance.current) === null || _b === void 0 ? void 0 : _b.getState()) === null || _c === void 0 ? void 0 : _c.coordinates;
    var src = (_e = (_d = instance.current) === null || _d === void 0 ? void 0 : _d.getImage()) === null || _e === void 0 ? void 0 : _e.src;
    var contentStyle = size
        ? {
            width: "".concat(size.width, "px"),
            height: "".concat(size.height, "px"),
        }
        : {};
    var refresh = function () {
        if (boundaryRef.current && coordinates) {
            boundaryRef.current.stretchTo(coordinates).then(function (size) {
                if (size && coordinates) {
                    if (advancedCropper.isGreater(advancedCropper.ratio(coordinates), advancedCropper.ratio(size))) {
                        setSize({
                            width: size.width,
                            height: size.width / advancedCropper.ratio(coordinates),
                        });
                    }
                    else {
                        setSize({
                            width: size.height * advancedCropper.ratio(coordinates),
                            height: size.height,
                        });
                    }
                }
                else {
                    setSize(null);
                }
            });
        }
        rerender();
    };
    useWindowResize(refresh);
    React.useLayoutEffect(refresh, [coordinates === null || coordinates === void 0 ? void 0 : coordinates.height, coordinates === null || coordinates === void 0 ? void 0 : coordinates.width]);
    React.useImperativeHandle(ref, function () { return ({
        refresh: rerender,
    }); });
    var WrapperComponent = wrapperComponent;
    var BackgroundComponent = backgroundComponent;
    var BoundaryComponent = boundaryComponent;
    return (React__default["default"].createElement(WrapperComponent, tslib.__assign({}, wrapperProps, { className: cn__default["default"](className, 'advanced-cropper-preview'), cropper: instance.current, style: style }),
        React__default["default"].createElement(BoundaryComponent, tslib.__assign({ ref: boundaryRef, stretchAlgorithm: advancedCropper.stretchPreviewBoundary }, boundaryProps, { className: cn__default["default"]('advanced-cropper-preview__boundary', boundaryClassName) }),
            React__default["default"].createElement("div", { className: cn__default["default"](contentClassName, 'advanced-cropper-preview__content'), style: contentStyle }, instance.current && (React__default["default"].createElement(BackgroundComponent, tslib.__assign({}, backgroundProps, { cropper: instance.current, size: size, className: cn__default["default"](backgroundClassName, 'advanced-cropper-preview__image', src && 'advanced-cropper-preview__image--visible') })))))));
});

function mergeRefs(refs) {
    return function (value) {
        refs.forEach(function (ref) {
            if (typeof ref === 'function') {
                ref(value);
            }
            else if (ref != null) {
                ref.current = value;
            }
        });
    };
}

Object.defineProperty(exports, 'isArray', {
    enumerable: true,
    get: function () { return advancedCropper.isArray; }
});
Object.defineProperty(exports, 'isGreater', {
    enumerable: true,
    get: function () { return advancedCropper.isGreater; }
});
Object.defineProperty(exports, 'isLower', {
    enumerable: true,
    get: function () { return advancedCropper.isLower; }
});
Object.defineProperty(exports, 'isMouseEvent', {
    enumerable: true,
    get: function () { return advancedCropper.isMouseEvent; }
});
Object.defineProperty(exports, 'isNumber', {
    enumerable: true,
    get: function () { return advancedCropper.isNumber; }
});
Object.defineProperty(exports, 'isNumeric', {
    enumerable: true,
    get: function () { return advancedCropper.isNumeric; }
});
Object.defineProperty(exports, 'isRoughlyEqual', {
    enumerable: true,
    get: function () { return advancedCropper.isRoughlyEqual; }
});
Object.defineProperty(exports, 'isTouchEvent', {
    enumerable: true,
    get: function () { return advancedCropper.isTouchEvent; }
});
Object.defineProperty(exports, 'isUndefined', {
    enumerable: true,
    get: function () { return advancedCropper.isUndefined; }
});
Object.defineProperty(exports, 'isWheelEvent', {
    enumerable: true,
    get: function () { return advancedCropper.isWheelEvent; }
});
exports.BoundingBox = BoundingBox;
exports.CircleStencil = CircleStencil;
exports.Cropper = Cropper;
exports.CropperBackgroundImage = CropperBackgroundImage;
exports.CropperBackgroundWrapper = CropperBackgroundWrapper;
exports.CropperCanvas = CropperCanvas;
exports.CropperFade = CropperFade;
exports.CropperPreview = CropperPreview;
exports.CropperPreviewBackground = CropperPreviewBackground;
exports.CropperPreviewWrapper = CropperPreviewWrapper;
exports.CropperSource = CropperSource;
exports.CropperWrapper = CropperWrapper;
exports.DraggableArea = DraggableElement;
exports.DraggableElement = DraggableElement;
exports.FixedCropper = FixedCropper;
exports.RectangleStencil = RectangleStencil;
exports.SimpleHandler = SimpleHandler;
exports.SimpleLine = SimpleLine;
exports.StencilGrid = StencilGrid;
exports.StencilOverlay = StencilOverlay;
exports.StencilWrapper = StencilWrapper;
exports.StretchableBoundary = StretchableBoundary;
exports.TransformableImage = TransformableImage;
exports.TransformableImageEvent = TransformableImageEvent;
exports.mergeRefs = mergeRefs;
exports.useAbstractCropper = useAbstractCropper;
exports.useCropperImage = useCropperImage;
exports.useCropperInstance = useCropperInstance;
exports.useMoveImageOptions = useMoveImageOptions;
exports.useScaleImageOptions = useScaleImageOptions;
exports.useUpdateEffect = useUpdateEffect;
exports.useWindowResize = useWindowResize;
Object.keys(advancedCropper).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return advancedCropper[k]; }
    });
});
Object.keys(service).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return service[k]; }
    });
});
Object.keys(state).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return state[k]; }
    });
});
Object.keys(defaults).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return defaults[k]; }
    });
});
Object.keys(algorithms).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return algorithms[k]; }
    });
});
Object.keys(image).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return image[k]; }
    });
});
Object.keys(canvas).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return canvas[k]; }
    });
});
//# sourceMappingURL=index.cjs.js.map
